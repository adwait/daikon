// ***** This file is automatically generated from ThreeScalar.java.jpp
package daikon.inv.ternary.threeScalar;

import daikon.*;
import daikon.inv.*;
import daikon.inv.ternary.TernaryInvariant;
import daikon.plumelib.util.FileIOException;

import org.checkerframework.checker.interning.qual.Interned;
import org.checkerframework.checker.lock.qual.GuardSatisfied;
import org.plumelib.util.Intern;
import typequals.prototype.qual.NonPrototype;
import typequals.prototype.qual.Prototype;

import putils.LispParser;
import putils.LispNode;

import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Scanner;

import java.io.File;
import java.io.FileWriter;
import java.io.FileNotFoundException;
import java.io.IOException;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
// import com.fasterxml.jackson.core.*;

/**
 * Abstract base class for invariants over three numeric variables. An example is {@code z = ax + by
 * + c}.
 */
public class TernaryRel extends ThreeScalar {
  // We are Serializable, so we specify a version to allow changes to
  // method signatures without breaking serialization.  If you add or
  // remove fields, you should change this number to the current date.
  static final long serialVersionUID = 20210802;

  public static int count = 0;
  public static String invstub = "rel1";
  public static boolean dkconfig_enabled = Invariant.invariantEnabledDefault;
  public static String funfile = "/home/adwait/Documents/daikonparent/daikon/synthinv/define.smt";
  public static String resultsfile = "/home/adwait/Documents/daikonparent/daikon/synthinv/results1.json";
  public static JSONObject obj = new JSONObject();
  public LispNode parsed_node;
  public final String invname;
  private static FileWriter file;

  private void parse_fun() {
    String acc = "";
    try {
      File myObj = new File(funfile);
      Scanner myReader = new Scanner(myObj);
      while (myReader.hasNextLine()) {
        acc += myReader.nextLine();
      }
      myReader.close();
    } catch (FileNotFoundException e) {
      System.out.println("An error occurred.");
      e.printStackTrace();
    }
    // System.out.println(acc);
    LispParser parser = new LispParser();
    this.parsed_node = parser.parse(acc);
  }


  protected TernaryRel(PptSlice ppt) {
    super(ppt);
    parse_fun();
    this.invname = invstub + String.valueOf(count);
  }

  protected @Prototype TernaryRel() {
    super();
    parse_fun();
    this.invname = invstub + String.valueOf(count);
  }

  private static @Prototype TernaryRel proto = new @Prototype TernaryRel();

  /** Returns the prototype invariant. */
  public static @Prototype TernaryRel get_proto() {
    return proto;
  }

  /** returns whether or not this invariant is enabled */
  @Override
  public boolean enabled() {
    return dkconfig_enabled;
  }

  /** instantiate an invariant on the specified slice */
  @Override
  public TernaryRel instantiate_dyn(@Prototype TernaryRel this, PptSlice slice) {
    return new TernaryRel(slice);
  }

  @Override
  protected Invariant resurrect_done(int[] permutation) {
    return this;
  }

  // A printed representation for user output
  @Override
  public String format_using(@GuardSatisfied TernaryRel this, OutputFormat format) {
    JSONArray vlist = new JSONArray();
    vlist.add(var1().name());
    vlist.add(var2().name());
    vlist.add(var3().name());
    obj.put(invname, vlist);
    // LispParser parser = new LispParser();
    // LispNode temp = parser.parse("(+ a b)");
    try {
      // TODO: need to ensure that the output is generated only once
      file = new FileWriter(resultsfile);
      file.write(obj.toJSONString());
    } catch (Exception e) {
      e.printStackTrace();
    } finally {
      try {
        file.flush();
        file.close();
      } catch (IOException e) {
        e.printStackTrace();
      }
    }
    return var1().name() + " " + var2().name() + " ternary inv!";
  }

  /**
   * Presents a sample to the invariant. Returns whether the sample is consistent with the
   * invariant. Does not change the state of the invariant.
   *
   * @param count how many identical samples were observed in a row. For example, three calls to
   * check_modified with a count parameter of 1 is equivalent to one call to check_modified with a
   * count parameter of 3.
   * @return whether or not the sample is consistent with the invariant
   */
  // public abstract InvariantStatus check_modified(long v1, long v2, long v3, int count);

  private long evaluate(long v1, long v2) {
    List<Long> arg_list = Arrays.asList(v1, v2);
    return parsed_node.evaluate(arg_list);
  }


  @Override
  public InvariantStatus check_modified(long v1, long v2, long v3, int count) {
    if (v3 != evaluate(v1, v2)) {
      return InvariantStatus.FALSIFIED;
    }
    return InvariantStatus.NO_CHANGE;
  }

  /**
   * Similar to {@link #check_modified} except that it can change the state of the invariant if
   * necessary. If the invariant doesn't have any state, then the implementation should simply call
   * {@link #check_modified}. This method need not check for falsification; that is done by the
   * caller.
   */
  // public abstract InvariantStatus add_modified(long v1, long v2, long v3, int count);
  @Override
  public InvariantStatus add_modified(long v1, long v2, long v3, int count) {
    return check_modified(v1, v2, v3, count);
  }

  @Override
  protected double computeConfidence() {
    // Assume that every variable has a .5 chance of being positive by
    // chance.  Then a set of n values have a have (.5)^n chance of all
    // being positive by chance.
    return 1;
    //  - Math.pow(.5, ppt.num_samples());
  }

  /** By default, do nothing if the value hasn't been seen yet. Subclasses can override this. */
  // public InvariantStatus add_unmodified(long v1, long v2, long v3, int count) {
  //   return InvariantStatus.NO_CHANGE;
  // }
  @Override
  public boolean isSameFormula(Invariant other) {
    assert other instanceof TernaryRel;
    return true;
  }

}
